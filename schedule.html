<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>選擇時段</title>
    <!-- 載入 LIFF SDK -->
    <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
    <!-- 載入共用設定檔 -->
    <script src="config.js"></script>
    <!-- 方案一：載入 Supabase JS SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- 新增：載入共用樣式表 -->
    <link rel="stylesheet" href="common.css">
    <!-- 新增：載入共用 UI 元件 -->
    <script src="ui-components.js"></script>
    <!-- 新增：載入 Google Material Symbols 圖示庫 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <!-- 新增：載入 Material Design Icons (MDI) 圖示庫 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css">
    <style>
        /* --- 1. 暗色主題 --- */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            background-color: #212529; 
            color: #e0e0e0; 
            /* padding: 40px 0; 由 main-container 控制 */
            display: flex;
            justify-content: center; /* 水平置中 .main-container */
        }
        .header h1 { margin: 0; font-size: 1.5em; color: #ffffff; }
        .header p { margin: 5px 0 0; color: #b0b0b0; }

        /* --- 新增：課表上方的資訊列 --- */
        .schedule-info-bar {
            display: flex; /* 改為 flex 佈局 */
            justify-content: space-between; /* 讓內容兩端對齊 */
            align-items: center; /* 垂直置中 */
            background-color: #495057; /* 改為與日期列相同的灰色背景 */
            color: #ffffff; /* 改為白色文字 */
            font-weight: normal; /* 移除粗體，與日期列一致 */
            height: 20px;
            font-size: 0.9em;
            width: 100%; /* 寬度與父容器相同 */
            padding: 0 10px; /* 增加左右內距，避免按鈕貼邊 */
            box-sizing: border-box;
            margin-bottom: 3px; /* 新增：與下方表格的間距 */
        }
        /* 新增：下方資訊列的樣式調整 */
        /* 新增：無時段提示的樣式 */
        .no-slots-message {
            text-align: center;
            padding: 4rem 0 !important; /* 增加上下間距，讓提示更突出 */
            font-size: 2rem;
            color: #868e96; /* 使用較柔和的灰色 */
        }

        .schedule-info-bar.bottom {
            margin-bottom: 0; /* 移除下方外距 */
            margin-top: 3px; /* 改為上方外距 */
        }
        .schedule-info-bar .info-text {
            flex-grow: 1; /* 讓文字區域填滿中間空間 */
            text-align: center;
        }
        .schedule-info-bar .week-nav-btn {
            background: none;
            border: none;
            color: #ffffff;
            font-size: 0.9em; /* 與資訊列文字大小一致 */
            cursor: pointer;
            padding: 0; /* 移除內距，讓文字自然對齊 */
        }

        /* --- 2. 恢復為大表格佈局 --- */
        .schedule-wrapper {
            padding: 0px;
            overflow-x: auto; /* 允許表格水平滾動 */
            overflow-y: hidden; /* 新增：明確禁止垂直捲動，避免出現不必要的捲軸 */
        }

        .schedule-grid {
            width: 100%; /* 讓表格寬度填滿容器 */
            border-collapse: collapse;
            text-align: center;
            table-layout: fixed;
            border-style: hidden; /* 隱藏外邊框 */
        }

        .schedule-grid th, .schedule-grid td {
            border: 1px solid #495057; /* 暗色邊框 */
            padding: 6px 2px;
            vertical-align: middle;
            height: 30px;
        }

        .schedule-grid thead th {
            background-color: #495057; /* 暗色表頭 */
            font-weight: normal;
            font-size: 0.9em; /* 微調字體大小 */
            padding: 0; 
            color: #ffffff;
        }

        .schedule-grid thead tr:nth-child(2) th {
            background-color: #343a40; /* 與儲存格同色 */
            color: #b0b0b0; /* 較柔和的文字顏色 */
            font-weight: normal;
            font-size: 0.9em;
            padding: 0;
        }

        .schedule-grid .time-label {
            background-color: #343a40; /* 暗色時間標籤 */
            font-size: 0.9em;
            color: #b0b0b0; /* 與星期列文字同色 */
        }

        .schedule-grid td {
            background-color: #343a40; /* 暗色儲存格 */
            transition: background-color 0.2s;
        }
        
        /* 時段狀態樣式 */
        .slot {
            /* 移除 font-size，改為直接控制圖示大小 */
            cursor: default;
        }
        /* 新增：MDI 圖示的通用樣式 */
        .slot .mdi {
            font-size: 1.6em; /* 調整圖示大小 */
            vertical-align: middle;
        }

        .slot.available {
            color: #ffc107; /* 橘黃色 */
            cursor: pointer;
        }
        .slot.available:hover .mdi {
            transform: scale(1.15); /* 滑鼠懸停時放大圖示 */
        }

        /* 當滑鼠經過可點擊的格子時，改變背景顏色 */
        .schedule-grid td.available:hover,
        .schedule-grid td.booked-by-me:hover {
            background-color: #495057;
        }
        .slot.full {
            color: #dc3545; /* 紅色，表示禁止 */
        }

        /* --- 新增：可展開儲存格的樣式 --- */
        .expandable {
            cursor: pointer; /* 讓整個儲存格都顯示可點擊的鼠標 */
        }
        /* 移除：不再需要 flex 佈局，因為只顯示一個圖示 */
        .expand-arrow {
            font-size: 0.8em; /* 讓箭頭比主圖示小一點 */
            color: #868e96; /* 柔和的灰色 */
            transition: transform 0.2s;
        }
        .expandable:hover .expand-arrow {
            color: #ffc107; /* 滑鼠懸停時變為黃色 */
        }

        /* --- 新增：展開後的子橫列樣式 --- */
        .sub-row td {
            background-color: #3c4248; /* 暗黃色/灰色背景 */
            transition: background-color 0.2s; /* 將樣式應用到 td 而不是 tr */
        }
        .sub-row .time-label {
            /* 修正：使用更明確的選擇器來覆蓋預設樣式，確保背景色一致 */
            background-color: #3c4248 !important; /* 使用 !important 強制覆蓋 */
            color: #fcc419; /* 改為主題黃色 */
            font-size: 0.9em; /* 確保字體大小與主時間列一致 */
        }
        /* 讓子橫列中的可點擊格子也有 hover 效果 */
        .sub-row td.available:hover,
        .sub-row td.booked-by-me:hover {
            background-color: #495057;
        }
        .slot.processing {
            color: #ffc107; /* 橘黃色 */
            cursor: wait;
            /* 新增：處理中狀態使用旋轉動畫 */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .slot.booked-by-me {
            color: #28a745; /* 綠色 */
            cursor: pointer; /* 讓圖示看起來可以點擊 */
        }
        .slot.expired {
            color: #6c757d; /* 灰色橫線 */
            font-weight: bold;
        }

        .loader, .error { text-align: center; font-size: 1.1em; color: #6c757d; padding: 2em; }
        .error { color: #dc3545; }

        /* --- 新增：通用 Modal 樣式 (從 manager.html 借鑒並簡化) --- */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #343a40;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            width: 80%;
            max-width: 240px;
            text-align: center;
            position: relative;
        }
        .modal-content h2 {
            margin-top: 0;
            border-bottom: 1px solid #495057;
            padding-bottom: 1rem;
            margin-bottom: 1rem;
        }
        .modal-content p {
            font-size: 1.1em;
            line-height: 1.6;
            color: #e0e0e0;
            margin-bottom: 1.5rem;
        }
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }
        #confirmation-message, #notification-message {
            display: flex;
            justify-content: flex-start;
            gap: 1rem;
            text-align: left;
            padding: 0 1.5rem;
        }

        /* --- 新增：通用按鈕樣式 (從 manager.html 借鑒) --- */
        .btn {
            border: none;
            border-radius: 8px;
            padding: 0.8rem 1.5rem;
            cursor: pointer;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            transition: background-color 0.2s, transform 0.2s;
            width: 100%;
            max-width: 400px; /* 與其他頁面按鈕最大寬度一致 */
            display: inline-block; /* 讓 max-width 生效 */
        }
        .btn:hover {
            transform: translateY(-1px);
        }
        .btn-success { background-color: #28a745; color: #ffffff; }
        .btn-success:hover { background-color: #218838; }
        .btn-secondary { background-color: #495057; color: #ffffff; }
        .btn-secondary:hover { background-color: #5a6268; }

        /* 新增：按鈕容器樣式 */
        .btn-container {
            text-align: center;
            margin: 1.5rem 0;
        }
    </style>
</head>
<body>

    <!-- 新增：使用通用容器包裹所有內容 -->
    <div class="main-container">
        <div id="header-container"></div>

        <div class="schedule-wrapper">
            <!-- 將資訊列移至 wrapper 內部，使其與表格貼齊 -->
            <div id="schedule-info-bar-container-top"></div>
            <div id="schedule-container">
                <p class="loader">正在載入時段資料...</p>
            </div>
            <!-- 新增：在表格下方也加上資訊列 -->
            <div id="schedule-info-bar-container-bottom"></div>
        </div>
        <!-- 新增：回到上一頁按鈕的容器 -->
        <div id="back-button-container" class="btn-container" style="display: none;">
            <button class="btn btn-secondary" onclick="goBackToCoachSelection()">重新選擇教練</button>
        </div>
    </div>

    <!-- 新增：卡片式通知 Modal -->
    <div id="notification-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="notification-title">通知</h2>
            <p id="notification-message"></p>
            <div id="notification-actions" class="modal-actions" style="justify-content: center;">
                <button id="notification-close-btn" class="btn btn-secondary">關閉</button>
                <button id="notification-action-btn" class="btn btn-success">執行動作</button>
            </div>
        </div>
    </div>
    <!-- 沿用 booking-details.html 的部分樣式，簡化通知卡片 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- 新增：確認對話框 Modal -->
    <div id="confirmation-modal" class="modal-overlay" style="z-index: 2001;">
        <div class="modal-content">
            <h2 id="confirmation-title" style="color: #ffc107;">請確認</h2>
            <p id="confirmation-message"></p>
            <div class="modal-actions" style="justify-content: center;">
                <button id="confirmation-cancel-btn" class="btn btn-secondary">取消</button>
                <button id="confirmation-confirm-btn" class="btn btn-success">確認</button>
            </div>
        </div>
    </div>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">


    <script>
        // --- 從 config.js 讀取設定 ---
        const { createClient } = supabase;
        const supabaseClient = createClient(AppConfig.SUPABASE_URL, AppConfig.SUPABASE_ANON_KEY);

        // --- 舊版 GAS 設定 (保留備用，預約時仍會用到) ---

        // 全域變數，用來存放使用者資訊
        let userProfile = null;
        let currentScheduleDate = new Date(); // 新增：用於追蹤目前課表顯示的週次
        let scheduleData = {}; // 新增：將 scheduleData 提升為全域變數

        window.addEventListener('DOMContentLoaded', main);

        async function main() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const debugMode = urlParams.get('debug') === 'true';
                console.log('Debug mode:', debugMode);

                // 渲染共用的頁首和頁尾
                renderHeaderAndFooter();

                // 步驟 1: 無論如何都先初始化 LIFF
                await liff.init({ liffId: AppConfig.LIFF_ID_SCHEDULE });
                console.log('LIFF initialized');

                // 步驟 2: 判斷是否登入
                if (liff.isLoggedIn()) {
                    // 已登入，取得使用者資料
                    userProfile = await liff.getProfile();
                    console.log('LIFF 登入成功，使用者:', userProfile.displayName);
                } else if (debugMode && !liff.isInClient()) {
                    // 未登入，但處於開發模式
                    userProfile = {
                        userId: 'U_DEV_000000000000000000000000001',
                        displayName: '開發者AA',
                    };
                    console.log('未登入，進入開發模式 (非 LINE 環境 + debug=true)，偽造的使用者資訊:', userProfile);
                } else {
                    // 未登入，且非開發模式，導向登入頁
                    console.log('未登入，準備導向 LINE 登入頁...');
                    liff.login();
                    return; // liff.login() 會跳轉頁面，此處 return 避免後續程式碼執行
                }

                // 2. 從 URL 取得課程 ID
                const courseId = urlParams.get('courseId');
                const courseName = urlParams.get('courseName');
                const coachId = urlParams.get('coachId');
                const coachName = urlParams.get('coachName');

                if (!courseId || !courseName || !coachId || !coachName) {
                    document.getElementById('header-container').innerHTML = '<h1>錯誤</h1>';
                    document.getElementById('schedule-container').innerHTML = '<p class="error">錯誤：缺少必要的課程或教練資訊。</p>';
                    return;
                }

                // 產生資訊列的 HTML
                const infoBarHtml = `
                    <div class="schedule-info-bar">
                        <button id="prev-week-btn" class="week-nav-btn">上一週</button>
                        <span class="info-text">${decodeURIComponent(courseName)} - ${decodeURIComponent(coachName)}</span>
                        <button id="next-week-btn" class="week-nav-btn">下一週</button>
                    </div>`;
                
                // 將資訊列填入上方和下方的容器
                document.getElementById('schedule-info-bar-container-top').innerHTML = infoBarHtml;
                document.getElementById('schedule-info-bar-container-bottom').innerHTML = infoBarHtml.replace(
                    'class="schedule-info-bar"',
                    'class="schedule-info-bar bottom"'
                );

                // 3. 顯示流程圖並載入時段資料
                document.getElementById('header-container').innerHTML = `
                    <div class="step-indicator">
                        <div class="step completed">
                            <div class="step-box">課程</div>
                        </div>
                        <span class="material-symbols-outlined connector completed">arrow_forward</span>
                        <div class="step completed">
                            <div class="step-box">教練</div>
                        </div>
                        <span class="material-symbols-outlined connector completed">arrow_forward</span>
                        <div class="step active">
                            <div class="step-box">時間</div>
                        </div>
                        <span class="material-symbols-outlined connector">arrow_forward</span>
                        <div class="step">
                            <div class="step-box">完成</div>
                        </div>
                    </div>`;

                await fetchSchedule(courseId, coachId, currentScheduleDate);

                // 新增：綁定上下週按鈕事件
                bindWeekChangeButtons(courseId, coachId);

            } catch (err) {
                console.error('初始化或載入時段失敗', err);
                document.getElementById('schedule-container').innerHTML = '<p class="error">頁面初始化失敗，請稍後再試。</p>';
            }
        }
        async function fetchSchedule(courseId, coachId, referenceDate) {
            const container = document.getElementById('schedule-container');
            const grid = container.querySelector('.schedule-grid');

            // 如果表格已存在，只清空內容並顯示載入中，避免閃爍
            if (grid) {
                const tbody = grid.querySelector('tbody');
                const thead = grid.querySelector('thead');
                if (tbody) {
                    const colspan = thead.querySelector('tr:first-child').children.length;
                    tbody.innerHTML = `<tr><td colspan="${colspan}" class="loader" style="height: 300px;">正在載入時段資料...</td></tr>`;
                }
            } else {
                // 第一次載入
                container.innerHTML = '<p class="loader">正在載入時段資料...</p>';
            }
            try {
                // --- Part 3.1: 互動式展開方案的後端資料準備 ---
                // 這是改造的第一步，我們將重構資料處理邏輯，
                // 以便為前端提供更豐富的資訊，判斷哪些時段需要「展開」。

                // --- 方案一：直接從 Supabase 讀取資料 (最終時區修正版) ---
                
                // 1. 建立日期輔助工具
                const refDate = new Date(referenceDate); // 使用傳入的日期作為基準
                const getLocalDateString = (date) => {
                    const year = date.getFullYear();
                    const month = (date.getMonth() + 1).toString().padStart(2, '0');
                    const day = date.getDate().toString().padStart(2, '0');
                    return `${year}-${month}-${day}`;
                };

                // 2. 計算要查詢的七天日期範圍
                // 修正：查詢範圍的起始日應為 referenceDate，與 renderScheduleGrid 的邏輯保持一致
                const startDate = new Date(refDate);
                const endDate = new Date(refDate);
                endDate.setDate(startDate.getDate() + 6); // 從起始日往後推 6 天，共 7 天

                const startDateString = getLocalDateString(startDate);
                const endDateString = getLocalDateString(endDate);

                // 3. 使用計算出的一週範圍查詢 Supabase
                const { data: classes, error: classesError } = await supabaseClient
                    .from('classes')
                    .select('*')
                    .eq('course_id', courseId)
                    .eq('coach_id', coachId)   // 篩選教練
                    .eq('status', '開放中')
                    .gte('class_date', startDateString) // 大於等於起始日
                    .lte('class_date', endDateString);  // 小於等於結束日

                if (classesError) throw classesError;
                
                if (!classes || classes.length === 0) {
                    renderScheduleGrid({}, referenceDate); // 傳入空物件以顯示「無時段」訊息
                    return;
                }

                // 4. 查詢使用者在這些課堂中的有效預約紀錄
                const classIds = classes.map(c => c.class_id);
                const userBookings = new Map();
                if (userProfile && userProfile.userId) {
                    const { data: bookings, error: bookingsError } = await supabaseClient
                        .from('bookings')
                        .select('class_id, booking_id')
                        .eq('line_user_id', userProfile.userId)
                        .in('class_id', classIds)
                        .in('status', ['已預約', '已扣款']);

                    if (bookingsError) throw bookingsError;
                    
                    bookings.forEach(b => userBookings.set(b.class_id, b.booking_id));
                }

                // 5. 建立一個新的、更豐富的七天空白課表資料結構
                scheduleData = {}; // 修正：賦值給全域變數，而不是宣告區域變數
                const hours = Array.from({length: 13}, (_, i) => (i + 9).toString().padStart(2, '0') + ':00');

                for (let i = 0; i < 7; i++) {
                    const currentDate = new Date(refDate);
                    currentDate.setDate(currentDate.getDate() + i);
                    const dateString = getLocalDateString(currentDate);

                    scheduleData[dateString] = {};
                    hours.forEach(hour => {
                        // 初始化每個小時的格子，包含一個空的 classes 陣列和 has_multiple 旗標
                        scheduleData[dateString][hour] = { 
                            has_multiple: false,
                            classes: [] 
                        };
                    });
                }

                // 6. 將從資料庫取得的課堂資料填入課表結構中
                classes.forEach(cls => {
                    const dateString = cls.class_date;
                    if (!cls.start_time || !scheduleData[dateString]) return;

                    const hourKey = cls.start_time.substring(0, 2) + ':00'; // e.g., "09:00"
                    const startTimeString = cls.start_time.substring(0, 5); // e.g., "09:15"

                    if (scheduleData[dateString][hourKey]) {
                        let classInfo;
                        if (userBookings.has(cls.class_id)) {
                            classInfo = { 
                                status: 'booked_by_me', 
                                schedule_id: cls.class_id, 
                                booking_id: userBookings.get(cls.class_id),
                                start_time: startTimeString // 儲存精確時間
                            };
                        } else {
                            const remaining = cls.max_students - cls.current_students;
                            classInfo = { 
                                status: remaining > 0 ? 'available' : 'full', 
                                schedule_id: cls.class_id, 
                                remaining: remaining,
                                start_time: startTimeString // 儲存精確時間
                            };
                        }
                        scheduleData[dateString][hourKey].classes.push(classInfo);
                    }
                });

                // 7. 判斷哪些時段需要標記為可展開 (has_multiple)
                for (const date in scheduleData) {
                    for (const hour in scheduleData[date]) {
                        const slot = scheduleData[date][hour];
                        // 新邏輯：只要該小時內有任何課堂（無論是一堂還是多堂，無論是否為整點），就標記為可展開。
                        if (slot.classes.length > 0) {
                            slot.has_multiple = true;
                        }
                    }
                }

                // 8. 渲染最終的課表網格
                renderScheduleGrid(scheduleData, referenceDate);

            } catch (error) {
                console.error('讀取時段資料時發生錯誤:', error);
                container.innerHTML = '<p class="error">載入時段資料失敗，請稍後再試或聯繫管理員。</p>';
            }
        }
        function renderScheduleGrid(scheduleData, referenceDate) {
            const container = document.getElementById('schedule-container');
            const hours = Array.from({length: 13}, (_, i) => (i + 9).toString().padStart(2, '0') + ':00'); // 09:00 to 21:00
            const now = new Date();

            // 根據 referenceDate 計算要顯示的七天日期
            // 修正：不再將一週的開始固定為星期日，而是直接從 referenceDate 開始
            const weekStartDate = new Date(referenceDate);
            const dates = Array.from({ length: 7 }, (_, i) => {
                const d = new Date(weekStartDate);
                d.setDate(d.getDate() + i);
                const year = d.getFullYear();
                const month = (d.getMonth() + 1).toString().padStart(2, '0');
                const day = d.getDate().toString().padStart(2, '0');
                return `${year}-${month}-${day}`;
            });

            // 產生兩列表頭
            let dateRow = `<tr><th>日期</th>`;
            let dayRow = `<tr><th>星期</th>`;

            dates.forEach(dateStr => {
                const d = new Date(dateStr);
                const day = ['日', '一', '二', '三', '四', '五', '六'][d.getDay()];
                dateRow += `<th>${(d.getMonth() + 1)}/${d.getDate()}</th>`; // 第一列：日期
                dayRow += `<th>${day}</th>`; // 3. 星期不需要括號
            });
            dateRow += '</tr>';
            dayRow += '</tr>';
            const headerHtml = dateRow + dayRow;

            let bodyHtml = '';
            // 檢查 scheduleData 是否為空物件
            if (Object.keys(scheduleData).length === 0) {
                // 如果沒有任何課堂資料，顯示全寬度提示訊息
                bodyHtml += `
                    <tr>
                        <td colspan="8" class="no-slots-message">此週無時段</td>
                    </tr>
                `;
            } else {
                // 如果有資料，才一行一行地畫出時段
                hours.forEach(hour => {
                    bodyHtml += `<tr><td class="time-label">${hour}</td>`;
                    dates.forEach(date => {
                        let slotClass = 'slot';
                        let slotContent = '';
                        let onClickAction = '';
                        let titleAttribute = ''; // 用於存放 tooltip 文字
                        let tdClass = ''; // 新增：用於存放 <td> 的 class
                        let tdDataAttributes = ''; // 新增：用於存放 data-* 屬性

                        // 修正：將 mainIcon 的宣告移到 if/else 之外，確保在所有路徑下都已定義
                        let mainIcon = '';

                        // 修正：組合出該時段的完整時間。將 'T' 換成空格，確保 JS 將其解析為本地時間而非 UTC。
                        const slotDateTime = new Date(`${date} ${hour}`);

                        // 優先判斷：是否已過期
                        if (slotDateTime < now) {
                            slotClass += ' expired';
                            mainIcon = '<span class="mdi mdi-minus-circle-outline"></span>';
                        } else {
                            // 若未過期，才根據後端資料來判斷狀態
                            const slotDataContainer = (scheduleData[date] && scheduleData[date][hour]) 
                                             ? scheduleData[date][hour]
                                             : { classes: [] };

                            // 改造：即使有多堂課，我們也只取第一堂課的狀態來顯示初始圖示
                            const slotData = slotDataContainer.classes.length > 0 
                                             ? slotDataContainer.classes[0] 
                                             : { status: 'no_class' };

                            // --- Part 3.2: 根據 has_multiple 旗標加上可展開的箭頭 ---
                            if (slotDataContainer.has_multiple) {
                                tdClass = 'expandable';
                                // 將點擊事件統一交給 expandHour 處理
                                onClickAction = `onclick="expandHour(this)"`;
                                // 將必要資訊存在 data-* 屬性中，方便 expandHour 函式讀取
                                tdDataAttributes = `data-date="${date}" data-hour="${hour}"`;
                                // 箭頭圖示
                                mainIcon = '<span class="expand-arrow mdi mdi-chevron-down"></span>';
                                // 即使只顯示箭頭，我們仍然需要根據第一堂課的狀態來設定顏色和提示
                                if (slotData.status === 'available') slotClass += ' available';
                                if (slotData.status === 'full') slotClass += ' full';
                                if (slotData.status === 'booked_by_me') slotClass += ' booked-by-me';
                                titleAttribute = 'title="點擊查看詳細時段"';
                            } else {
                                // 根據新邏輯，這個 else 區塊實際上不會被執行到，
                                // 因為所有有課的時段 (available, full, booked_by_me) 都會被標記為 has_multiple。
                                // 'no_class' 狀態則維持 mainIcon 為空字串，自然地顯示為空格子。
                            }
                        }
                        // 組合最終的 <td>，將主圖示和箭頭圖示組合在一起
                        bodyHtml += `<td class="${tdClass}" ${tdDataAttributes} ${onClickAction} ${titleAttribute}>
                                        <div class="${slotClass}">${mainIcon}${slotContent}</div>
                                     </td>`;
                    });
                    bodyHtml += '</tr>';
                });
            }

            // 檢查表格是否已存在
            let grid = container.querySelector('.schedule-grid');
            if (!grid) {
                // 如果不存在，建立完整的表格
                container.innerHTML = `<table class="schedule-grid"><thead>${headerHtml}</thead><tbody>${bodyHtml}</tbody></table>`;
            } else {
                // 如果已存在，只更新 thead 和 tbody
                grid.querySelector('thead').innerHTML = headerHtml;
                grid.querySelector('tbody').innerHTML = bodyHtml;
            }
            
            // 新增：顯示返回按鈕
            document.getElementById('back-button-container').style.display = 'block';
        }

        function showBookingDetails(bookingId) {
            // 新增：確保 debug 模式可以被傳遞到下一個頁面
            const urlParams = new URLSearchParams(window.location.search);
            const debugParam = urlParams.get('debug') === 'true' ? `&debug=true` : '';
            window.location.href = `booking-details.html?id=${bookingId}${debugParam}`;
        }

        // --- 新增：切換週次功能 ---
        function bindWeekChangeButtons(courseId, coachId) {
            // 為上下兩個資訊列的按鈕都綁定事件
            document.querySelectorAll('.week-nav-btn').forEach(btn => {
                if (btn.id.includes('prev-week-btn')) {
                    btn.addEventListener('click', () => changeWeek(-7, courseId, coachId));
                } else if (btn.id.includes('next-week-btn')) {
                    btn.addEventListener('click', () => changeWeek(7, courseId, coachId));
                }
            });
        }

        function changeWeek(days, courseId, coachId) {
            currentScheduleDate.setDate(currentScheduleDate.getDate() + days);
            fetchSchedule(courseId, coachId, currentScheduleDate);
        }

        /**
         * 新增：返回教練選擇頁面
         * 這個函式會從當前 URL 讀取課程資訊，並建立一個明確的 URL 返回到教練選擇頁，
         * 比 window.history.back() 更為可靠。
         */
        function goBackToCoachSelection() {
            const urlParams = new URLSearchParams(window.location.search);
            const courseId = urlParams.get('courseId');
            const courseName = urlParams.get('courseName');
            const debugParam = urlParams.get('debug') === 'true' ? '&debug=true' : '';

            if (courseId && courseName) {
                window.location.href = `coaches.html?courseId=${courseId}&courseName=${courseName}${debugParam}`;
            } else {
                window.history.back(); // 如果缺少參數，則退回使用 history.back()
            }
        }

        // --- Part 3.3: 互動邏輯 ---
        function expandHour(cell) {
            const parentRow = cell.parentElement;

            // --- 收合邏輯 ---
            if (parentRow.classList.contains('is-expanded')) {
                parentRow.classList.remove('is-expanded');
                let nextRow = parentRow.nextElementSibling;
                for (let i = 0; i < 4; i++) {
                    if (!nextRow || !nextRow.classList.contains('sub-row')) break;
                    const rowToRemove = nextRow;
                    nextRow = nextRow.nextElementSibling;
                    rowToRemove.remove();
                }
                return;
            }

            // --- 暫時停用：自動收合其他已展開的列 (未來可能重新啟用) ---
            /*
            const currentlyExpandedRow = document.querySelector('.schedule-grid tbody tr.is-expanded');
            if (currentlyExpandedRow) {
                currentlyExpandedRow.classList.remove('is-expanded');
                let nextRow = currentlyExpandedRow.nextElementSibling;
                for (let i = 0; i < 4; i++) {
                    if (!nextRow || !nextRow.classList.contains('sub-row')) break;
                    const rowToRemove = nextRow;
                    nextRow = nextRow.nextElementSibling;
                    rowToRemove.remove();
                }
            }
            */

            // --- 展開邏輯 ---
            parentRow.classList.add('is-expanded');
            const { date, hour } = cell.dataset;
            const subRowsHtml = generateSubRowsHtml(date, hour);
            parentRow.insertAdjacentHTML('afterend', subRowsHtml);
        }

        /**
         * 輔助函式：產生四個子橫列的 HTML 字串
         */
        function generateSubRowsHtml(date, hour) {
            const hourNumber = parseInt(hour.substring(0, 2), 10);
            const now = new Date();
            
            const weekDates = Array.from(document.querySelectorAll('#schedule-container thead tr:first-child th')).slice(1).map(th => {
                const [month, day] = th.textContent.split('/');
                const year = new Date(date).getFullYear();
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            });

            const weeklySubSlots = getWeeklySubSlots(weekDates, hour);
            let subRowsHtml = '';

            ['00', '15', '30', '45'].forEach(minute => {
                subRowsHtml += `<tr class="sub-row" data-parent-hour="${hour}">`;
                subRowsHtml += `<td class="time-label">${hourNumber}:${minute}</td>`;
                for (let i = 0; i < 7; i++) {
                    const currentDate = weekDates[i];
                    const subSlotDateTime = new Date(`${currentDate} ${hourNumber}:${minute}`);
                    const classInfo = weeklySubSlots[currentDate]?.[minute];
                    subRowsHtml += generateSubCellHtml(subSlotDateTime, now, classInfo);
                }
                subRowsHtml += `</tr>`;
            });
            return subRowsHtml;
        }

        /**
         * 輔助函式：從全域 scheduleData 整理出一週內特定小時的子時段資料
         */
        function getWeeklySubSlots(weekDates, hour) {
            const weeklySubSlots = {};
            weekDates.forEach(d => {
                const slotDataContainer = scheduleData[d]?.[hour] || { classes: [] };
                if (slotDataContainer.classes.length > 0) {
                    weeklySubSlots[d] = {};
                    slotDataContainer.classes.forEach(cls => {
                        const minute = cls.start_time.substring(3, 5);
                        if (!weeklySubSlots[d][minute]) {
                            weeklySubSlots[d][minute] = cls;
                        }
                    });
                }
            });
            return weeklySubSlots;
        }

        /**
         * 輔助函式：產生單一子儲存格 (<td>) 的 HTML
         */
        function generateSubCellHtml(subSlotDateTime, now, classInfo) {
            if (subSlotDateTime < now) {
                return `<td><div class="slot expired"><span class="mdi mdi-minus-circle-outline"></span></div></td>`;
            }

            if (!classInfo) {
                return `<td><div class="slot"></div></td>`;
            }

            let tdClass = '';
            let mainIcon = '';
            let onClickAction = '';
            let titleAttribute = '';

            switch (classInfo.status) {
                case 'available':
                    tdClass = 'available';
                    mainIcon = '<span class="mdi mdi-circle-outline"></span>';
                    onClickAction = `onclick="selectTimeslot('${classInfo.schedule_id}', this)"`;
                    titleAttribute = `title="剩下 ${classInfo.remaining} 位"`;
                    break;
                case 'full':
                    tdClass = 'full';
                    mainIcon = '<span class="mdi mdi-close"></span>';
                    titleAttribute = 'title="額滿"';
                    break;
                case 'booked_by_me':
                    tdClass = 'booked-by-me';
                    mainIcon = '<span class="mdi mdi-check"></span>';
                    onClickAction = `onclick="showBookingDetails('${classInfo.booking_id}')"`;
                    titleAttribute = 'title="查看憑證"';
                    break;
            }
            // 修正：將 slotClass (available, full...) 直接應用在 <td> 上
            return `<td class="${tdClass}" ${onClickAction} ${titleAttribute}>
                        <div class="slot ${tdClass}">${mainIcon}</div>
                    </td>`;
        }

        async function selectTimeslot(scheduleId, element) {
            if (!userProfile) {
                showNotification('無法取得使用者資訊，請重新整理頁面。', 'error');
                return;
            }

            // Fetch class details to display in confirmation modal
            const { data: classData, error: classError } = await supabaseClient
                .from('classes_with_details')
                .select('*')
                .eq('class_id', scheduleId)
                .single();

            if (classError) {
                showNotification('無法取得課程資訊，請稍後再試。', 'error');
                return;
            }

            const { course_name, class_date, start_time, coach_name } = classData;

            // 將 YYYY-MM-DD 格式的日期轉換為 MM/DD
            const dateParts = class_date.split('-');
            const formattedDate = `${dateParts[1]}/${dateParts[2]}`;
            const classTime = `${formattedDate} ${start_time.substring(0, 5)}`;
            const message = `課程名稱 : ${course_name}<br>上課時間 : ${classTime}<br>教練名稱 : ${coach_name}`;


            const confirmed = await showConfirmation(message, {
                title: '確認預約',
                confirmText: '預約'
            });
            if (!confirmed) {
                return;
            }

            const originalContent = element.innerHTML; // 儲存原始內容
            // 提供即時反饋：禁用點擊並顯示處理中狀態
            element.onclick = null;
            element.classList.remove('available');
            element.classList.add('processing');
            element.innerHTML = '<div class="slot processing"><span class="mdi mdi-loading"></span></div>';

            try {                
                // --- 方案二：前端直接呼叫 Supabase RPC ---
                console.log(`[Booking] 直接呼叫 Supabase RPC 'create_booking_atomic'，classId: ${scheduleId}`);
                const { data, error } = await supabaseClient.rpc('create_booking_atomic', {
                    p_class_id: scheduleId,
                    p_user_id: userProfile.userId,
                    p_display_name: userProfile.displayName
                });

                if (error) throw error;

                const result = data[0]; // RPC 回傳的是陣列，取第一個元素
                console.log('[Booking] 後端回傳結果:', result);

                if (result.status === 'success') {
                    // 預約成功，直接導向到「預約完成」頁面，不再顯示彈窗
                    const urlParams = new URLSearchParams(window.location.search);
                    const debugParam = urlParams.get('debug') === 'true' ? '&debug=true' : '';
                    const bookingId = result.booking_id;
                    // 將 bookingId 和 debug 參數一起傳遞下去
                    window.location.href = `booking-complete.html?bookingId=${bookingId}${debugParam}`;
                    // 因為頁面即將跳轉，所以不需要再重新載入課表
                    
                } else {
                    // 如果預約失敗，將格子恢復原狀
                    throw new Error(result.message || '預約失敗，請稍後再試。');
                }
            } catch (error) {
                console.error('[Booking] 預約時發生錯誤:', error);
                // 恢復格子為可點擊狀態，讓使用者可以重試
                element.innerHTML = originalContent;
                element.classList.remove('processing');
                element.classList.add('available');
                element.onclick = () => selectTimeslot(scheduleId, element);
            }
        }

        // --- 新增：確認對話框函式 (回傳 Promise) ---
        function showConfirmation(message, options = {}) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmation-modal');
                const titleEl = document.getElementById('confirmation-title');
                const messageEl = document.getElementById('confirmation-message');
                const confirmBtn = document.getElementById('confirmation-confirm-btn');
                const cancelBtn = document.getElementById('confirmation-cancel-btn');

                // 從 options 或預設值設定內容
                titleEl.textContent = options.title || '請確認';
                messageEl.innerHTML = message; // 使用 innerHTML 來解析 <br> 標籤
                confirmBtn.textContent = options.confirmText || '確認';
                cancelBtn.textContent = options.cancelText || '取消';

                // 顯示 Modal
                modal.style.display = 'flex';

                const close = (result) => {
                    // 隱藏 Modal
                    modal.style.display = 'none';

                    // 移除事件監聽器，避免重複綁定
                    confirmBtn.onclick = null;
                    cancelBtn.onclick = null;
                    modal.onclick = null;
                    resolve(result);
                };

                confirmBtn.onclick = () => close(true);
                cancelBtn.onclick = () => close(false);
                // 點擊背景遮罩等同於取消
                modal.onclick = (event) => { if (event.target === modal) close(false); };
            });
        }

        // --- 新增：卡片式通知函式 ---
        function showNotification(message, options = {}) {
            const modal = document.getElementById('notification-modal');
            const titleEl = document.getElementById('notification-title');
            const messageEl = document.getElementById('notification-message');
            const actionsContainer = document.getElementById('notification-actions');
            const closeBtn = document.getElementById('notification-close-btn'); // The '關閉' button
            const actionBtn = document.getElementById('notification-action-btn'); // The '執行動作' button

            const type = options.type || 'info';

            // 設定標題、訊息和按鈕文字
            titleEl.textContent = options.title || (type === 'success' ? '操作成功' : (type === 'error' ? '發生錯誤' : '通知'));
            // 修正：如果 message 為空，則隱藏訊息段落，否則顯示它
            if (message) {
                messageEl.innerHTML = message; // 使用 innerHTML 來解析 <br> 標籤
                messageEl.style.display = 'block';
            } else {
                messageEl.innerHTML = '';
                messageEl.style.display = 'none';
            }

            // 重設樣式
            titleEl.style.color = '';
            actionBtn.style.display = 'none'; // 預設隱藏動作按鈕
            actionsContainer.style.justifyContent = 'center'; // 預設置中

            switch (type) {
                case 'success':
                    titleEl.style.color = '#28a745';
                    break;
                case 'error':
                    titleEl.style.color = '#dc3545';
                    break;
                default: // 'info' 或其他
                    titleEl.style.color = '#ffc107';
                    break;
            }

            // 處理按鈕
            closeBtn.textContent = options.closeButtonText || '確認';

            if (typeof options.action === 'function' && options.actionButtonText) {
                actionBtn.textContent = options.actionButtonText;
                actionBtn.style.display = 'inline-block';
                actionBtn.onclick = () => {
                    modal.style.display = 'none';
                    options.action();
                };
            }

            modal.style.display = 'flex'; // 顯示 Modal

            // 綁定按鈕事件
            const closeModal = () => {
                modal.style.display = 'none';
                // 移除事件監聽器以防記憶體洩漏
                closeBtn.onclick = null;
                actionBtn.onclick = null;
            };

            closeBtn.onclick = closeModal;
        }
    </script>

</body>
</html>